<!DOCTYPE html>
<html>
  <head>
    <title>Curveball</title>
    <script type="application/javascript" src="jquery-2.1.4.min.js"></script>
		<script type="application/javascript" src="three.min.js"></script>
		<script type="application/javascript" src="init.js"></script>
		<script type="application/javascript" src="add_events.js"></script>
		<script type="application/javascript" src="ball.js"></script>
		<script type="application/javascript" src="paddle.js"></script>
  </head>
  <body>
    <div id="canvas" style="width: 1000px; height: 600px;"></div>
    <script>
      var canvasWidth, canvasHeight;
      var scene, camera, renderer;
      var leftWallMesh, rightWallMesh, floorMesh, ceilingMesh;
      var ballMesh, playerMesh, compMesh;
      var ball, player, comp;

      var wallWidth = 60;
      var wallHeight = 40;
      var wallDepth = 1;
      var distance = 90;
      var radius = 3;
      var paddleWidth = 12;
      var paddleHeight = 8;

      init();
      addEvents();
      animate();

      function animate() {
        requestAnimationFrame(animate);
        renderer.render(scene, camera);

        detectCollisions();
        player.updatePos();
        ball.spin();

        ballMesh.position.x += ball.speedX;
        ballMesh.position.y += ball.speedY;
        ballMesh.position.z += ball.speedZ;
      }

      function detectCollisions() {
        if (ballMesh.position.x <= leftWallMesh.position.x + radius) {
          ballMesh.position.x = leftWallMesh.position.x + radius;
          ball.speedX *= -1;
        } else if (ballMesh.position.x >= rightWallMesh.position.x - radius) {
          ballMesh.position.x = rightWallMesh.position.x - radius;
          ball.speedX *= -1;
        }

        if (ballMesh.position.y <= floorMesh.position.y + radius) {
          ballMesh.position.y = floorMesh.position.y + radius;
          ball.speedY *= -1;
        } else if (ballMesh.position.y >= ceilingMesh.position.y - radius) {
          ballMesh.position.y = ceilingMesh.position.y - radius;
          ball.speedY *= -1;
        }

        if (ballMesh.position.z < -distance + radius) {
          if (paddleCollision(-1)) {
            ballMesh.position.z = -distance + radius;
            ball.speedZ *= -1;
            getPaddleSpeed();
          } else {
            ball.stop();
            setTimeout(function () {
              ball.reset();
            }, 1000);
          }
        } else if (ballMesh.position.z > -radius) {
          if (paddleCollision(1)) {
            ballMesh.position.z = -radius;
            ball.speedZ *= -1;
            getPaddleSpeed();
          } else {
            ball.stop();
            setTimeout(function () {
              ball.reset();
            }, 1000);
          }
        }
      }

      function paddleCollision (dir) {
        if (ball.dead) return;

        var points = ball.getCollisionPoints();
        var vectorDir = new THREE.Vector3();
        vectorDir.z = 1 * dir;
        for (var i = 0; i < points.length; i++) {
          var raycaster = new THREE.Raycaster(points[i], vectorDir);
          var intersects = raycaster.intersectObjects(scene.children);
          if (intersects.length > 0) {
            return true;
          }
        }
        return false;
      }

      function getPaddleSpeed () {
        var oldX = playerMesh.position.x;
        var oldY = playerMesh.position.y;
        setTimeout(function () {
          ball.updateSpin(oldX, oldY, playerMesh);
        }, 0);
      }
    </script>
  </body>
</html>
